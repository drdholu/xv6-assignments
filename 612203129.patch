diff --git a/kalloc.c b/kalloc.c
index 14cd4f4..22cf0dd 100644
--- a/kalloc.c
+++ b/kalloc.c
@@ -15,6 +15,7 @@ extern char end[]; // first address after kernel loaded from ELF file
 
 struct run {
   struct run *next;
+  struct run *prev; // converting to a doubly circular linked list
 };
 
 struct {
@@ -33,6 +34,7 @@ kinit1(void *vstart, void *vend)
 {
   initlock(&kmem.lock, "kmem");
   kmem.use_lock = 0;
+  kmem.freelist = 0;
   freerange(vstart, vend);
 }
 
@@ -69,9 +71,16 @@ kfree(char *v)
 
   if(kmem.use_lock)
     acquire(&kmem.lock);
-  r = (struct run*)v;
-  r->next = kmem.freelist;
-  kmem.freelist = r;
+  if(kmem.freelist == 0){ 
+    kmem.freelist = (struct run*)v;
+    kmem.freelist->next = kmem.freelist->prev = kmem.freelist;
+  }else{
+      r = (struct run*)v;
+      r->next = kmem.freelist;
+      r->prev = kmem.freelist->prev;
+      kmem.freelist->prev->next = r;
+      kmem.freelist = r;
+  }
   if(kmem.use_lock)
     release(&kmem.lock);
 }
@@ -87,8 +96,17 @@ kalloc(void)
   if(kmem.use_lock)
     acquire(&kmem.lock);
   r = kmem.freelist;
-  if(r)
-    kmem.freelist = r->next;
+  if(r){
+      struct run *x = kmem.freelist->prev;
+      if(kmem.freelist == x){
+          kmem.freelist = 0;
+      }else{
+          r->next->prev = r->prev;
+          r->prev->next = r->next;
+          kmem.freelist = r->next;
+      }
+      r->prev = r->next = 0;
+  }
   if(kmem.use_lock)
     release(&kmem.lock);
   return (char*)r;
